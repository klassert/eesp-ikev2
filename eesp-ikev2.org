# -*- fill-column: 69; -*-
# vim: set textwidth=69
# Do: title, toc:table-of-contents ::fixed-width-sections |tables
# Do: ^:sup/sub with curly -:special-strings *:emphasis
# Don't: prop:no-prop-drawers \n:preserve-linebreaks ':use-smart-quotes
#+OPTIONS: prop:nil title:t toc:t \n:nil ::t |:t ^:{} -:t *:t ':nil

#+RFC_CATEGORY: std
#+RFC_NAME: draft-klassert-ipsecme-eesp-ikev2
#+RFC_VERSION: 00
#+RFC_IPR: trust200902
#+RFC_STREAM: IETF
#+RFC_XML_VERSION: 3
#+RFC_CONSENSUS: true

#+TITLE: IKEv2 negotiation for Enhanced Encapsulating Security Payload
#+RFC_SHORT_TITLE: EESP IKEv2 negotiation
#+AUTHOR: Steffen Klassert
#+EMAIL: steffen.klassert@secunet.com
#+AFFILIATION: secunet Security Networks AG
#+RFC_SHORT_ORG: secunet
#+RFC_ADD_AUTHOR: ("Antony Antony" "antony.antony@secunet.com" ("secunet" "secunet Security Networks AG"))
#+RFC_ADD_AUTHOR: ("Tobias Brunner" "tobias@codelabs.ch" ("" "codelabs GmbH"))
#+RFC_ADD_AUTHOR: ("Valery Smyslov" "svan@elvis.ru" ("" "ELVIS-PLUS"))
#+RFC_AREA: SEC
#+RFC_WORKGROUP: IPSECME Working Group

#+begin_abstract
This document species how to negotiate Enhanced Encapsulating
Security Payload (EESP) Security Associations using IKEv2. EESP
which builds on the existing IP Encapsulating Security Payload (ESP)
protocol.

#+end_abstract

#+RFC_KEYWORDS: ("EESP" "IKEv2")

* Introduction


The Enhanced Encapsulating Security Payload (EESP), specified in
[[I-D.klassert-ipsecme-eesp]], introduces enhancements to the
Encapsulating Security Payload (ESP) defined in [RFC4303]. These
improvements address evolving requirements in modern IPsec
deployments. EESP offers increased flexibility for hardware
offloads at the packet level. It supports carrying inner packet flow
identifiers for the use with ECMP, RSS hardware, and IPsec peers
prior to decryption. EESP also enables the establishment of Sub Child
SAs with independent sequence number spaces. Additionally, it
supports the use of 64-bit sequence numbers in each packet or the
omission of sequence numbers when the Replay Protection service is
disabled. EESP packets carry a version number, enabling easier
support for future extensions.

This document specifies the negotiation of EESP Security
Associations (SAs) within the Internet Key Exchange Protocol
Version 2 (IKEv2) protocol [RFC7296]. It details the creation,
rekeying, and deletion of EESP SAs, as well as the negotiation of
EESP specific transform properties and properties.

The extensions defined here enable EESP SAs to coexist with ESP SAs
in stateful decryption configurations, while introducing new capabilities
to enhance IPsec’s performance and versatility in modern use cases.

EESP Sub SA is a single unidirectional, outgoing, SA derived from
a pair Child SAs negotiated using IKEv2. Each Sub SA derive
its own unique encryption key and maintain independent sequence
number spaces, and IV spaces from an existing Child SA, Sub SAs
streamline traffic flow management, reduce overhead, and enable more
efficient lifecycle operations.

This document does not obsolete or update any existing RFCs. While
stateless implementations of EESP are referenced, their negotiation,
which is similar to [[PSP]], is outside the scope of this document.

** Requirements Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 [[RFC2119]] [[RFC8174]] when, and only when, they
appear in all capitals, as shown here.

** Terminology
It is assumed that readers are familiar with the IKEv2 negotiation
[[RFC7296]], IPsec architecture [[RFC4301]] and ESP [[RFC4303]].
This document uses a notation and conventions from IKEv2 [RFC7296]
to negotiate EESP.

This document uses the following terms defined in IKEv2 [[RFC7296]]:
Child SA, CREATE_CHILD_SA exchange, IKE_AUTH exchange,
USE_TRANSPORT_MODE

This document uses the following terms defined in [[PSP]]: PSP (a
recursive acronym for PSP Security Protocol), Network Identifier
(VNI), Crypt Offset.

This document uses the following terms defined in [[RFC2992]]:
Equal-cost multi-path (ECMP)

This document uses the following terms defined in [[RFC4303]]:
Encapsulating Security Payload (ESP).

This document uses the following terms defined in
[[I-D.mrossberg-ipsecme-multiple-sequence-counters]]: Sub-Child SA.

This document uses the following terms defined in
[[I-D.ietf-ipsecme-ikev2-rename-esn]] : Replay Protection.

This document uses the following terms defined in
[[I-D.ietf-ipsecme-g-ikev2]]: Sender-ID, Data-Security SA,
GWP_SENDER_ID_BITS, GCKS policy.

* EESP SA IKEv2 Negotiation
To negotiate of EESP Security Associations (SAs), as specified
in [[I-D.klassert-ipsecme-eesp]]. Propose ~Protocol ID~ EESP input
SA Payload, Proposal payload.
These extensions provide the ability to establish EESP SAs using
the IKE_AUTH or the CREATE_CHILD_SA exchanges. The initiator includes
EESP-specific transforms and attributes in the proposal, allowing
the responder to evaluate and establish the SA if supported.

IKEv2 Notify Message Status Type USE_WESP_MODE, [[RFC5840]], is not
supported when negotiating EESP SA. As the WESP functionality
is part of EESP protocol. If this notification is received it
MUST be discarded.

The ESP_TFC_PADDING_NOT_SUPPORTED, [[RFC7296]], notification is not
supported in EESP, instead use IP-TFS, USE_AGGFRAG, [[RFC9347]].
If this notification is received it MUST be discarded.

** Negotiating an EESP SA using IKE_AUTH or CREATE_CHILD_SA
To negotiate an EESP Child SA, use the IKEv2 IKE_AUTH or
CREATE_CHILD_SA new SA exchange. The SA Payload, Proposal
MUST have Security Protocol Identifier, Proto Id = EESP
which is specified in [[I-D.klassert-ipsecme-eesp]],
as specified in this document, and uses the
EESP Transform attributes defined in [[EESP SA Transforms]].

** Rekeying an EESP SA with the CREATE_CHILD_SA Exchange
Rekeying an EESP SA follows the same procedure as rekeying an ESP SA,
as specified in Sections 1.3.3 and 2.8 of [[RFC7296]]. During the
rekeying process, the [[EESP SA Transforms]] MUST remain identical to
those negotiated when the SA was initially established.

** Deleting EESP SA with INFORMATIONAL Exchange

EESP SA always exist in pairs. Deleting EESP SA follows the same
procedure as deleting Child SA using IKEv2 INFORMATIONAL exchange as
specified in Section 1.4.1 [[RFC7296]]

* EESP SA Transforms
EESP introduces several transform properties that are negotiated
during the establishment of an EESP SA. These properties MUST be
identical for the duration of the SA. When the SA is rekeyed,
the new SA MUST inherit all EESP transform properties negotiated for
the original EESP SA.

| Type | Description               | Used In | Reference       |
|------+---------------------------+---------+-----------------+
| TBD6 | EESP Session ID(EESPSID)  |  (EESP) | [this document] |

#+caption: EESP SA proposal
#+name: eesp-sa-proposal
#+begin_src
   SA Payload
      |
      +--- Proposal #1 ( Proto ID = EESPv0(<TBD1>), SPI size = 4,
      |     |            8 transforms,      SPI = 0x052357bb )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 128 )
      |     +-- Transform INTEG ( Name = AUTH_HMAC_SHA1_96 )
      |     +-- Transform INTEG ( Name = AUTH_AES_XCBC_96 )
      |     +-- Transform SN ( Name = 64-bit Sequential Numbers )
#+end_src

** Replay Protection Service
EESP provides an optional Replay service using
64-bit sequence numbers carried in the packet.
To enable Replay service the initiator SHOULD
propose Sequence Numbers Transforms,
SN = (64-bit Sequential Numbers) in the
Proposal Substructure inside the Security Association (SA) payload
in the IKEv2 Exchange. When the responder selects 64-bit Sequential Numbers, a
both sides MUST enable Reply Protection.

# NOTE STK: I'd say MUST above as we want to negotiate Anti-Replay service
# and not just the presense of the seq nr field.

To disable sequence numbering, and thus replay protection based on
sequence numbers, the initiator MUST propose SN=None (<TBD5>). When the
sequence numbers are disabled, there won't be any SN in the
EESP packet, the receiver SHOULD NOT dynamically modify ports or
addresses without using IKEv2 Mobility [[RFC4555]].

Because the Replay Protection service is disabled, an attacker can re
play packets with a different source address. Such an attacker could
disrupt the connection by replaying a single packet with a different
source address or port number.

** Explicit Initialization Vector

If the algorithm used to encrypt the payload requires cryptographic
synchronization data, e.g., an Initialization Vector (IV), then this
may be carried explicitly in every EESP packet.

** Implicit Initialization Vectors

With the Implicit Initialization Vector (IIV) encryption algorithm,
as specified in [[RFC8750]], the IV MUST be omitted in the EESP
packet. To enable this functionality, IIV transforms defined in
[[IKEv2-Enc]] MUST be used during negotiation. Furthermore,
the [[IKEv2-SN]] extension MUST be negotiated to support the use of
64-bit Sequential Numbers in EESP packets. If the the proposal
does not include 64-bit Sequential Numbers return error
NO_PROPOSAL_CHOSEN.

** EESP Version
Each EESP packets carry EESP Base Header version, which is specified
[[I-D.klassert-ipsecme-eesp]]. This SHOULD BE negotiated using
IKEv2. Each Base Header version, to be able to negotiate via IKEv2,
SHOULD have a corresponding ~IKEv2 Security Protocol Identifiers~
The initial version sepecified EESPv0(TBD1)

* Sub SA
Existing mechanisms for establishing Child SAs, as described in
[[RFC7296]], yield pair of SAs. High-speed IP traffic is often
asymmetric. Creating multiple pairs of Child SAs, e.g. [[RFC9611]] or
for DSCP to carry asymetric traffic is inefficient. A pair of Child SA
combined with multiple unidirectional a set of  Sub SAs with Sub SA
IDs greater than 0, provides a more flexible approach to carrying
asymmetric traffic patterns, particularly in high-speed environments.
Sub SAs reduces overhead, improves resource utilization, and enhances
scalability for large-scale deployments. In many use cases, several
uni directinal SAs utilized, while others are unused which can result
in unnecessary overhead for management, rekeying, and resource
consumption. Furthermore, using multiple bidirectional Child SAs for
granular traffic flows often leads to additional setup delays and
complex lifetime management. This inefficiency is particularly acute
in high-throughput or low-latency environments, where rapid setup and
teardown of SAs is essential to maintain performance.

An EESP Sub SA provides a unidirectional Security Association
derived from an existing EESP Child SA pair.  It inherits all of
the Child SA’s properties except for keys, sequence number space,
and IV space, each of which MUST be unique to each Sub SA.  By
defining these unidirectional flows, Sub SAs offer a more efficient
alternative to large numbers of bidirectional Child SAs with the
same traffic selectors [[RFC7296]], [[RFC9611]].

Each Sub SA is identified by a Sub SA ID, which MUST be carried in
each EESP packet in the Session ID field—consistent with the negotiation of the EESP Child SA.  This
Sub SA ID is used to derive a unique key, yielding the following
benefits:

- Unidirectional Operation: In contrast to the per-resource
  SAs of [[RFC9611]], which are bidirectional, Sub SAs MAY be
  defined strictly in one direction when reverse traffic is
  absent.  CREATE_CHILD_SA does not otherwise support
  unidirectional SAs.

- Zero Additional Setup Time: Sub SAs require no extra IKE
  message exchanges, unlike requesting more Child SAs or relying
  on large IKE windows [[RFC7296]].  This allows rapid provisioning
  of extra flows without introducing round-trip delays.

- Simplified Lifecycle Management**: Sub SAs are more efficient
  to create, rekey, and delete than traditional Child SAs.  Their
  narrow scope streamlines both key management and policy
  enforcement.

- On-the-Fly Key Derivation: Implementations using hierarchical
  key derivation, particularly with hardware offload, MAY derive
  Sub SA keys dynamically on a per-packet basis.  This mitigates
  the risk of data-plane performance degradation caused by a large
  number of keys [[I-D.ponchon-ipsecme-anti-replay-subspaces]].

AEAD transforms such as AES-GCM [[RFC4106]], [[RFC8750]] require
that the IV never repeat within a single Sub SA.  Because each
Sub SA uses a distinct key, the IV MAY be reused across different
Sub SAs, satisfying the requirement that each key be paired with a
unique IV.  Implementations MUST also maintain an independent
sequence number space for each Sub SA when full 64-bit sequence
numbers are in use.  For a given Sub SA key, sequence numbers MUST
remain unique and monotonically increasing to meet cryptographic
requirements.

** Negotiation of Sub SA

#+caption: Sub SA Notifier
#+name: sub-sa-notifier
#+begin_src
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-----------------------------+-------------------------------+
! Next Payload  !C!  RESERVED   !         Payload Length        !
+---------------+---------------+-------------------------------+
!  Protocol ID  !   SPI Size    !      Notify Message Type      !
+---------------+---------------+-------------------------------+
!  Minimum number of Sub SAs    |      RESERVED                 !
+-------------------------------+-------------------------------+
#+end_src

- Protocol ID (1 octet) - MUST be 0. MUST be ignored if not 0.
- SPI Size (1 octet) - MUST be 0. MUST be ignored if not 0.
- Notify Status Message Type (2 octets) - set to <TBDXXX>.
- Minimum number of Sub SAs (2 octets). MUST be greater than 0.
  If 0 is received, it MUST be interpreted as 1.

** UDP Encapsulation of Sub SA

An EESP SA primarily uses UDP encapsulation to facilitate NAT
traversal.  However, an additional use case for UDP encapsulation is
to introduce source port entropy, which supports ECMP or/and
RSS (Receive Side Scaling) mechanisms. In such scenarios, the
initiator MAY also use a distinct, ephemeral source port for
Sub SA IDs greater than zero. Both peers MAY independently select
different source ports for the same Sub SA ID.

It is important to note that IKE messages MUST NOT utilize these
ephemeral source ports. Instead, IKE traffic should be confined to
the source and destination ports to ensure proper protocol operation
and maintain compatibility with existing implementations.

When using ephemeral source ports, the receiver can only set the
source port upon arrival of an EESP packet with that Sub SA ID. If
the receiver is pre-populating a Sub SA, it may have to install it
with a source port set to zero and, upon arrival of a packet,
update the source port using a mapping change.

Additionally, when multiple Sub SAs exist, the receiver SHOULD
maintain a mapping table to track the source port associated with
each Sub SA independently. This ensures that traffic is correctly
routed and prevents ambiguity in handling packets associated with
different Sub SAs when a NAT is present.

** Key Derivation for Sub SAs

When an EESP SA is using Sub SAs, each Sub SA (including the one
with Session ID 0) uses separate keys. This allows each Sub SA to use
its own independent Sequence Number and IV space.

In order to derive these keys, a Sub SA Key Derivation Function
(SSKDF) is negotiated as part of the proposal of the EESP SA using
Transform Type <TBD2>. This SSKDF is independent of the PRF
negotiated for IKEv2.

If no Sub SAs are to be used for an EESP SA, Transform Type <TBD2>
SHOULD be omitted in the proposal, but it MAY be NONE. If it's
omitted or NONE is selected by the responder, Sub SAs MUST NOT be
created by either peer and the key derivation for the in- and
outbound EESP SAs of the Child SA are done as described in section
2.17 of [[RFC7296]].

If an SSKDF is selected as part of the proposal, instead of directly
taking keys for the Sub SAs from KEYMAT, as described in section 2.17
of [[RFC7296]], only one "root" key is taken for each EESP SA of the
Child SA. Their length is determined by the key size of the
negotiated SSKDF.  The root key for the EESP SA carrying data from
the initiator to the responder is taken before that for the SA going
from the responder to the initiator.

Using the EESP SA's root key, SK_sub, the KEYMAT for each Sub SA is
derived as follows:

    KEYMAT_sub = SSKDF(SK_sub, SPI | Session_ID, L)

Where L is the total length of the key material KEYMAT_sub and the
salt value is comprised of the full SPI and the full Session ID of
the Sub SA.

If multiple keys are required for a Sub SA, the encryption key MUST
be taken from the first bits of KEYMAT_sub, the integrity key MUST be
taken from the remaining bits.

Keys for Sub SAs may be derived immediately or on demand when the
first packet is processed. Memory constrained implementations may
even decide to derive the Sub SA keys on the fly for each received
packet as only SK_sub has to be stored to derive the keys of all
Sub SAs.

Because individual Sub SAs can't be rekeyed, the complete EESP Child
SA MUST be rekeyed when either a cryptographic limit or a time-based
limit is reached for any individual Sub SA.

*** Sub SA Key Derivation Function Transform

The new Sub SA Key Derivation Function (SSKDF) transform is used to
negotiate a key derivation function for Sub SAs as described in the
previous section.

This document creates a new IKEv2 IANA registry for key derivation
functions that can be negotiated with this transform type. The
initially defined Transform IDs are listed in the table below.

#+caption: Sub SA Key Derivation Functions
| Value   | Algorithm           |
|---------+---------------------+
| 0       | NONE                |
| 1       | SSKDF_HKDF_SHA2_256 |
| 2       | SSKDF_HKDF_SHA2_384 |
| 3       | SSKDF_HKDF_SHA2_512 |
| 4       | SSKDF_AES256_CMAC   |

These algorithms are defined as follows:

- SSKDF_HKDF_SHA2_256, SSKDF_HKDF_SHA2_384 and SSKDF_HKDF_SHA2_512
  use HKDF-Expand defined in [[RFC5869]] with the indicated hash
  functions, that is, SHA-256, SHA-384 or SHA-512, respectively, with
  corresponding key sizes of 32, 48 and 64 octets. SSKDF is then
  defined as:

  SSKDF(K, S, L) = HKDF-Expand(K, S, L)

- SSKDF_AES256_CMAC is currently undefined

Other key derivation functions may be added after the publication of
this document. Readers should refer to [[IKEv2-IANA]] for the latest
values.

The type of the Sub SA Key Derivation Function transform is <TBA2>.

** Multiple Sender Group SA Key Derivation

When using EESP with a group SA, as specified in
[[I-D.ietf-ipsecme-g-ikev2]], the Sender-ID MUST be used for
deriving a unique key for each sender. This ensures that each
sender maintains a distinct IV and/or sequence number space.
When using independent keys, the Implicit IV (IIV) transforms
may be used.

The Sender-ID is carried in each packet within the Session ID
field, allowing efficient and reliable key differentiation for
data security and integrity.

The maximum length of GWP_SENDER_ID_BITS in GCKS policy
is 16 bits when using the Session ID to carry the Sender-ID.

[Note: we could allow 32 bit or any lenght field for
GWP_SENDER_ID_BITS then it would have be carried in
a EESP Options TLV and not in Session ID]

* Session ID

The Session ID is a multi-purpose attribute with mutually
exclusive values. The initiator MUST propose a single value in the
Child SA proposal, Transform EESPSSID (Value). The responder MUST
either accept the proposed value or reject it with an
INVALID_SESSION_ID error message, indicating a supported value.

* UDP Encapsulation for EESP

UDP encapsulation for EESP is largely similar to the ESP UDP
encapsulation specified in [[RFC3948]], with the primary difference
being the UDP source port used by the EESP Sub SA may be different
from IKE_SA source port, as specified in [[RFC3947]], for more
flexible handling of EESP traffic, particularly ECMP support
along the path and in the NIC.

A receiver indenting to support both ESP and EESP encapsulated in UDP
must start ESP  SPI, most significant bit of the SPI, with zero.

* EESP Crypt Offset Option
This option is typically used for within one Datacenter use case
such as [[PSP]]. To negotiate, the initiator sends USE_CRYPTOFFSET
together with USE_TRANSPORT_MODE and the responder respond with the
same. USE_EESP_CRYPTOFFSET is not supported in Tunnel mode or BEET
mode.
# Note STK:  This needs discussion
#
~NOTE~ Add EESP draft UDP section reference.

* IANA Considerations

** Changes in the Existing IKEv2 Registries

*** IKEv2 Security Protocol Identifiers registry
This document defines new Protocol ID in the
"IKEv2 Security Protocol Identifiers" registry, [[IKEv2-SP]]:

| Protocol ID | Protocol | Reference       |
|-------------+----------+-----------------+
| <TBD1>      | EESPv0   | [this document] |

*** IKEv2 Transform Type Values

#+caption: "Transform Type Values" Registry
| Type   | Description                            |  Reference      |
|--------+----------------------------------------+-----------------+
| <TBD2> | Sub SA Key Derivation Function (SSKDF) | [this document] |

This new Transform Type is only valid for EESP. Valid Transform IDs
are defined in a new registry listed in [[tbl-sskdfids]].

*** IKEv2 Notify Message Status Types registry.

| Value  | Notify Message Status Type |  Reference      |
|--------+----------------------------+-----------------+
| <TBD3> | USE_EESP_CRYPTOFFSET       | [this document] |

*** Extending ESP with EESP
Several tables in [[IKEv2-IANA]] that specify ESP as protocol
should be extended with EESP. Should we list each table one by one or
specify as replace ESP, with ESP, EESP.e.g in the Transform Type Values,
replace 'IKE and ESP' with 'IKE, ESP, and EESP'

Changes the "Used In" column for the existing allocations as follows;

*** Sequence Number

This document defines a new value in the IKEv2 "Transform Type 5 - Sequence
   Numbers Properties Transform IDs" registry:

| Value   | Name                          | Reference       |
|---------+-------------------------------+-----------------+
| <TBD4>  | 64-bit Sequential Numbers     | [this document] |
| <TBD5>  | None                          | [this document] |

** New IKEv2 Registries

A new set of registries is created for G-IKEv2 on IKEv2
parameters page [[IKEv2-IANA]]. The terms
Reserved, Expert Review and Private Use are to be applied as defined
in [[RFC8126]].

*** Transform Type <TBD2> - Sub SA Key Derivation Function Transform IDs

# what KDFs should we actually define here? more/less?
# SSKDF_AES256_CMAC is currently unspecified

This documents creates the new IKEv2 registry "Transform Type <TBD2> -
Sub SA Key Derivation Function Transform IDs".  The initial values of this
registry are:

#+caption: "Transform Type <TBD2>" Registry
#+name: tbl-sskdfids
| Number  | Name                          | Reference       |
|---------+-------------------------------+-----------------+
| 0       | NONE                          | [this document] |
| 1       | SSKDF_HKDF_SHA2_256           | [this document] |
| 2       | SSKDF_HKDF_SHA2_384           | [this document] |
| 3       | SSKDF_HKDF_SHA2_512           | [this document] |
| 4       | SSKDF_AES256_CMAC             | [TBD]           |
| 5-1023  | Unassigned                    | [this document] |
| 1024-65535| Private use                 | [this document] |

Changes and additions to the unassigned range of this registry are
by the Expert Review Policy [[RFC8126]].

*** Guidance for Designated Experts

In all cases of Expert Review Policy described here,
the Designated Expert (DE) is expected to ascertain the existence of suitable
documentation (a specification) as described in [[RFC8126]] and to
verify that the document is permanently and publicly available.  The
DE is also expected to check the clarity of purpose and use of the
requested code points. Last, the DE must verify that any specification produced outside the IETF does not
conflict with work that is active or already published within the IETF.

* Implementation Status

[Note to RFC Editor: Please remove this section and the reference to
[[RFC7942]] before publication.]

This section records the status of known implementations of the
protocol defined by this specification at the time of posting of this
Internet-Draft, and is based on a proposal described in [[RFC7942]].
The description of implementations in this section is intended to
assist the IETF in its decision processes in progressing drafts to
RFCs. Please note that the listing of any individual implementation
here does not imply endorsement by the IETF. Furthermore, no effort
has been spent to verify the information presented here that was
supplied by IETF contributors. This is not intended as, and must not
be construed to be, a catalog of available implementations or their
features. Readers are advised to note that other implementations may
exist.

According to [[RFC7942]], "this will allow reviewers and working
groups to assign due consideration to documents that have the benefit
of running code, which may serve as evidence of valuable
experimentation and feedback that have made the implemented protocols
more mature. It is up to the individual working groups to use this
information as they see fit".

Authors are requested to add a note to the RFC Editor at the top of
this section, advising the Editor to remove the entire section before
publication, as well as the reference to [[RFC7942]].


* Security Considerations

EESP option Crypt Offset [[I-D.klassert-ipsecme-eesp]] section [XXX]
allows exposing transport headers for telemetry.
It is indented use of within data center.

When an EESP receiver implementation uses Stateless Decryption, it
may not rely on single Security Policy Database (SPD) as specified in
the IPsec Architecture document [[RFC4301]], section 4.4.1. However,
the receiver MUST validate the negotiated Security Policy through
other means to ensure compliance with the intended security
requirements. For by adding Security Policy to the socket or route
entry. Also comply with ICMP  processing specified  in section 6 of
[[RFC4301]].

Additional security relevant aspects of using the IPsec protocol are
discussed in the Security Architecture document [[RFC4301]].

* Acknowledgments

TBD

* Normative References

** RFC8174
** RFC5840
** RFC4303
** RFC7296
** RFC3948
** RFC4301
** RFC8126
** I-D.klassert-ipsecme-eesp
** I-D.ietf-ipsecme-ikev2-rename-esn


* Informative References

** RFC2119
** RFC9347
** RFC9611
** RFC3947
** RFC2992
** RFC7942
** RFC8750
** RFC4555
** RFC4106
** RFC5869

** I-D.mrossberg-ipsecme-multiple-sequence-counters
** I-D.ponchon-ipsecme-anti-replay-subspaces
** I-D.ietf-ipsecme-g-ikev2

** PSP
:PROPERTIES:
:REF_TARGET: https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf
:REF_TITLE: PSP Architecture Specification
:REF_ORG: Google
:END:

** IKEv2-IANA
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml
:REF_TITLE: IKEv2 Parameters
:REF_ORG: IANA
:END:

** IKEv2-Transforms
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-3
:REF_TITLE: IKEv2 Parameters: Transform Type Values
:REF_ORG: IANA
:END:

** IKEv2-SN
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-9
:REF_TITLE: IKEv2 Parameters: Encryption Algorithm Transform IDs
:REF_ORG: IANA
:END:

** IKEv2-Enc
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-5
:REF_TITLE: IKEv2 Parameters: Extended Sequence Numbers Transform IDs
:REF_ORG: IANA
:END:

** IKEv2-SP
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-18
:REF_TITLE: IKEv2 Parameters: Security Protocol Identifiers
:REF_ORG: IANA
:END:


* Additional Stuff

TBD
