# -*- fill-column: 69; -*-
# vim: set textwidth=69
# Do: title, toc:table-of-contents ::fixed-width-sections |tables
# Do: ^:sup/sub with curly -:special-strings *:emphasis
# Don't: prop:no-prop-drawers \n:preserve-linebreaks ':use-smart-quotes
#+OPTIONS: prop:nil title:t toc:t \n:nil ::t |:t ^:{} -:t *:t ':nil

#+RFC_CATEGORY: std
#+RFC_NAME: draft-klassert-ipsecme-eesp-ikev2
#+RFC_VERSION: 00
#+RFC_IPR: trust200902
#+RFC_STREAM: IETF
#+RFC_XML_VERSION: 3
#+RFC_CONSENSUS: true

#+TITLE: IKEv2 negotiation for Enhanced Encapsulating Security Payload
#+RFC_SHORT_TITLE: EESP IKEv2 negotiation
#+AUTHOR: Steffen Klassert
#+EMAIL: steffen.klassert@secunet.com
#+AFFILIATION: secunet Security Networks AG
#+RFC_SHORT_ORG: secunet
#+RFC_ADD_AUTHOR: ("Antony Antony" "antony.antony@secunet.com" ("secunet" "secunet Security Networks AG"))
#+RFC_ADD_AUTHOR: ("Tobias Brunner" "tobias@codelabs.ch" ("" "codelabs GmbH"))
#+RFC_ADD_AUTHOR: ("Valery Smyslov" "svan@elvis.ru" ("" "ELVIS-PLUS"))
#+RFC_AREA: SEC
#+RFC_WORKGROUP: IPSECME Working Group

#+begin_abstract
This document species how to negotiate Enhanced Encapsulating
Security Payload (EESP) Security Associations using IKEv2. EESP
which builds on the existing IP Encapsulating Security Payload (ESP)
protocol.

This documents also updates RFC7296 by adding new Security Protocol
type EESP.

#+end_abstract

#+RFC_KEYWORDS: ("EESP" "IKEv2")

* Introduction


The Enhanced Encapsulating Security Payload (EESP), specified in
[[I-D.klassert-ipsecme-eesp]], introduces enhancements to the
Encapsulating Security Payload (ESP) defined in [RFC4303]. These
improvements address evolving requirements in modern IPsec
deployments. EESP offers increased flexibility for hardware
offloads at the packet level. It supports carrying inner packet flow
identifiers for the use with ECMP, RSS hardware, and IPsec peers
prior to decryption. EESP also enables the establishment of Sub Child
SAs with independent sequence number spaces. Additionally, it
supports the use of 64-bit sequence numbers in each packet or the
omission of sequence numbers when the Replay Protection service is
disabled. EESP packets carry a version number, enabling easier
support for future extensions.

This document specifies the negotiation of EESP Security
Associations (SAs) within the Internet Key Exchange Protocol
Version 2 (IKEv2) protocol [RFC7296]. It details the creation,
rekeying, and deletion of EESP SAs, as well as the negotiation of
EESP specific transform properties and properties.

The extensions defined here enable EESP SAs to coexist with ESP SAs
in stateful decryption configurations, while introducing new capabilities
to enhance IPsec’s performance and versatility in modern use cases.

EESP Sub SA is a single unidirectional, outgoing, SA derived from
a pair Child SAs negotiated using IKEv2. Each Sub SA derive
its own unique encryption key and maintain independent sequence
number spaces, and IV spaces from an existing Child SA, Sub SAs
streamline traffic flow management, reduce overhead, and enable more
efficient lifecycle operations.

This document does not obsolete or update any existing RFCs. While
stateless implementations of EESP are referenced, their negotiation,
which is similar to [[PSP]], is outside the scope of this document.

** Requirements Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 [[RFC2119]] [[RFC8174]] when, and only when, they
appear in all capitals, as shown here.

** Terminology
It is assumed that readers are familiar with the IKEv2 negotiation
[[RFC7296]], IPsec architecture [[RFC4301]] and ESP [[RFC4303]].
This document uses a notation and conventions from IKEv2 [RFC7296]
to negotiate EESP.

This document uses the following terms defined in IKEv2 [[RFC7296]]:
Child SA, CREATE_CHILD_SA exchange, IKE_AUTH exchange,
USE_TRANSPORT_MODE

This document uses the following terms defined in [[PSP]]: PSP (a
recursive acronym for PSP Security Protocol), Network Identifier
(VNI), Crypt Offset.

This document uses the following terms defined in [[RFC2992]]:
Equal-cost multi-path (ECMP)

This document uses the following terms defined in [[RFC4303]]:
Encapsulating Security Payload (ESP).

This document uses the following terms defined in
[[I-D.mrossberg-ipsecme-multiple-sequence-counters]]: Sub-Child SA.

This document uses the following terms defined in
[[I-D.ietf-ipsecme-ikev2-rename-esn]] : Replay Protection.

This document uses the following terms defined in
[[I-D.ietf-ipsecme-g-ikev2]]: Sender-ID, Data-Security SA,
GWP_SENDER_ID_BITS, GCKS policy.

* EESP SA IKEv2 Negotiation
To negotiate of EESP Security Associations (SAs), as specified
in [[I-D.klassert-ipsecme-eesp]]. Propose ~Protocol ID~ EESP input
SA Payload, Proposal payload.
These extensions provide the ability to establish EESP SAs using
the IKE_AUTH or the CREATE_CHILD_SA exchanges. The initiator includes
EESP-specific transforms and attributes in the proposal, allowing
the responder to evaluate and establish the SA if supported.

IKEv2 Notify Message Status Type USE_WESP_MODE, [[RFC5840]], is not
supported when negotiating EESP SA. As the WESP functionality
is part of EESP protocol. If this notification is received it
MUST be discarded.

The ESP_TFC_PADDING_NOT_SUPPORTED, [[RFC7296]], notification is not
supported in EESP, instead use IP-TFS, USE_AGGFRAG, [[RFC9347]].
If this notification is received it MUST be discarded.

** Negotiating an EESP SA using IKE_AUTH or CREATE_CHILD_SA
To negotiate an EESP Child SA, use the IKEv2 IKE_AUTH or
CREATE_CHILD_SA new SA exchange. The SA Payload, Proposal
MUST have Security Protocol Identifier, Proto Id = EESP
which is specified in [[I-D.klassert-ipsecme-eesp]],
as specified in this document, and uses the
EESP Transform attributes defined in [[EESP SA Transforms]].

** Rekeying an EESP SA with the CREATE_CHILD_SA Exchange
Rekeying an EESP SA follows the same procedure as rekeying an ESP SA,
as specified in Sections 1.3.3 and 2.8 of [[RFC7296]]. During the
rekeying process, the [[EESP SA Transforms]] MUST remain identical to
those negotiated when the SA was initially established.

** Deleting EESP SA with INFORMATIONAL Exchange

EESP SA always exist in pairs. Deleting EESP SA follows the same
procedure as deleting Child SA using IKEv2 INFORMATIONAL exchange as
specified in Section 1.4.1 [[RFC7296]]

* EESP SA Transforms
EESP introduces several transform properties that are negotiated
during the establishment of an EESP SA. These properties MUST be
identical for the duration of the SA. When the SA is rekeyed,
the new SA MUST inherit all EESP transform properties negotiated for
the original EESP SA.

| Type | Description               | Used In | Reference       |
|------+---------------------------+---------+-----------------+
| TBD6 | EESP Session ID(EESPSID)  |  (EESP) | [this document] |

#+caption: EESP SA proposal
#+name: eesp-sa-proposal
#+begin_src
   SA Payload
      |
      +--- Proposal #1 ( Proto ID = EESPv0(TBD1), SPI size = 4,
      |     |            8 transforms,      SPI = 0x052357bb )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 128 )
      |     +-- Transform INTEG ( Name = AUTH_HMAC_SHA1_96 )
      |     +-- Transform INTEG ( Name = AUTH_AES_XCBC_96 )
      |     +-- Transform SN ( Name = 64-bit Sequential Numbers )
#+end_src

** Replay Protection Service
EESP provides an optional Replay service using
64-bit sequence numbers carried in the packet.
To enable Replay service the initiator SHOULD
propose Sequence Numbers Transforms,
SN = (64-bit Sequential Numbers) in the
Proposal Substructure inside the Security Association (SA) payload
in the IKEv2 Exchange. When the responder selects 64-bit Sequential Numbers, a
both sides MUST enable Reply Protection.

# NOTE STK: I'd say MUST above as we want to negotiate Anti-Replay service
# and not just the presense of the seq nr field.

To disable sequence numbering, and thus replay protection based on
sequence numbers, the initiator MUST propose SN=None (TBD10). When the
sequence numbers are disabled, there won't be any SN in the
EESP packet, the receiver SHOULD NOT dynamically modify ports or
addresses without using IKEv2 Mobility [[RFC4555]].

Because the Replay Protection service is disabled, an attacker can re
play packets with a different source address. Such an attacker could
disrupt the connection by replaying a single packet with a different
source address or port number.

** Explicit Initialization Vector

If the algorithm used to encrypt the payload requires cryptographic
synchronization data, e.g., an Initialization Vector (IV), then this
may be carried explicitly in every EESP packet.

** Implicit Initialization Vectors

With the Implicit Initialization Vector (IIV) encryption algorithm,
as specified in [[RFC8750]], the IV MUST be omitted in the EESP
packet. To enable this functionality, IIV transforms defined in
[[IKEv2-Enc]] MUST be used during negotiation. Furthermore,
the [[IKEv2-SN]] extension MUST be negotiated to support the use of
64-bit Sequential Numbers in EESP packets. If the the proposal
does not include 64-bit Sequential Numbers return error
NO_PROPOSAL_CHOSEN.

** EESP Version
Each EESP packets carry EESP Base Header version, which is specified
[[I-D.klassert-ipsecme-eesp]]. This SHOULD BE negotiated using
IKEv2. Each Base Header version, to be able to negotiate via IKEv2,
SHOULD have a corresponding ~IKEv2 Security Protocol Identifiers~
The initial version sepecified EESPv0(TBD1)

* Sub SA
Existing mechanisms for establishing Child SAs, as described in
[[RFC7296]], yield pair of SAs. High-speed IP traffic is often
asymmetric. Creating multiple pairs of Child SAs, e.g. [[RFC9611]] or
for DSCP to carry asymetric traffic is inefficient. A pair of Child SA
combined with multiple unidirectional a set of  Sub SAs with Sub SA
IDs greater than 0, provides a more flexible approach to carrying
asymmetric traffic patterns, particularly in high-speed environments.
Sub SAs reduces overhead, improves resource utilization, and enhances
scalability for large-scale deployments. In many use cases, several
uni directinal SAs utilized, while others are unused which can result
in unnecessary overhead for management, rekeying, and resource
consumption. Furthermore, using multiple bidirectional Child SAs for
granular traffic flows often leads to additional setup delays and
complex lifetime management. This inefficiency is particularly acute
in high-throughput or low-latency environments, where rapid setup and
teardown of SAs is essential to maintain performance.

An EESP Sub SA provides a unidirectional Security Association
derived from an existing EESP Child SA pair.  It inherits all of
the Child SA’s properties except for keys, sequence number space,
and IV space, each of which MUST be unique to each Sub SA.  By
defining these unidirectional flows, Sub SAs offer a more efficient
alternative to large numbers of bidirectional Child SAs with the
same traffic selectors [[RFC7296]], [[RFC9611]].

Each Sub SA is identified by a Sub SA ID, which MUST be carried in
each EESP packet in the Session ID field—consistent with the negotiation of the EESP Child SA.  This
Sub SA ID is used to derive a unique key, yielding the following
benefits:

- Unidirectional Operation: In contrast to the per-resource
  SAs of [[RFC9611]], which are bidirectional, Sub SAs MAY be
  defined strictly in one direction when reverse traffic is
  absent.  CREATE_CHILD_SA does not otherwise support
  unidirectional SAs.

- Zero Additional Setup Time: Sub SAs require no extra IKE
  message exchanges, unlike requesting more Child SAs or relying
  on large IKE windows [[RFC7296]].  This allows rapid provisioning
  of extra flows without introducing round-trip delays.

- Simplified Lifecycle Management**: Sub SAs are more efficient
  to create, rekey, and delete than traditional Child SAs.  Their
  narrow scope streamlines both key management and policy
  enforcement.

- On-the-Fly Key Derivation: Implementations using hierarchical
  key derivation, particularly with hardware offload, MAY derive
  Sub SA keys dynamically on a per-packet basis.  This mitigates
  the risk of data-plane performance degradation caused by a large
  number of keys [[I-D.ponchon-ipsecme-anti-replay-subspaces]].

AEAD transforms such as AES-GCM [[RFC4106]], [[RFC8750]] require
that the IV never repeat within a single Sub SA.  Because each
Sub SA uses a distinct key, the IV MAY be reused across different
Sub SAs, satisfying the requirement that each key be paired with a
unique IV.  Implementations MUST also maintain an independent
sequence number space for each Sub SA when full 64-bit sequence
numbers are in use.  For a given Sub SA key, sequence numbers MUST
remain unique and monotonically increasing to meet cryptographic
requirements.

** Negotiation of Sub SAs

Sub SAs are negotiated during the creation of an EESP Child SA, such
as in the IKE_AUTH or CREATE_CHILD_SA new SA exchanges. To propose
Sub SA support, the initiator MUST include a USE_EESP_SUB_SA
notification, which specifies the "Minimum Number of Sub SAs"
that it supports.

If the responder accepts the request, it MUST include a
USE_EESP_SUB_SA notification in the response, specifying the
"Maximum Number of Sub SAs" it supports. The negotiated number
of Sub SAs for the Child SA MUST be the minimum value between
these two numbers.

Both peers MUST ensure that the number of Sub SAs established
complies with the negotiated limit. If at any point a peer attempts
to exceed the agreed number, the implementation MUST reject such an
attempt and log an appropriate error.

If the response does not include USE_EESP_SUB_SA or the responder
indicates a lower "Maximum Number of Sub SAs" than proposed, the
initiator MAY delete the Child SA.

#+caption: Sub SA Notifier
#+name: sub-sa-notifier
#+begin_src
                    1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-----------------------------+-------------------------------+
! Next Payload  !C!  RESERVED   !         Payload Length        !
+---------------+---------------+-------------------------------+
!  Protocol ID  !   SPI Size    !      Notify Message Type      !
+---------------+---------------+-------------------------------+
!  Minimum number of Sub SAs    |      RESERVED                 !
+-------------------------------+-------------------------------+
#+end_src

- Protocol ID (1 octet) - MUST be 0. MUST be ignored if not 0.
- SPI Size (1 octet) - MUST be 0. MUST be ignored if not 0.
- Notify Status Message Type (2 octets) - set to [TBD1]
- Minimum number of Sub SAs (2 octets). MUST be greater than 0,
  If 0 is received, it MUST be interpreted as 1.


** UDP Encapsulation of Sub SA

An EESP SA primarily uses UDP encapsulation to facilitate NAT
traversal.  However, an additional use case for UDP encapsulation is
to introduce source port entropy, which supports ECMP or/and
RSS (Receive Side Scaling) mechanisms. In such scenarios, the
initiator MAY also use a distinct, ephemeral source port for
Sub SA IDs greater than zero. Both peers MAY independently select
different source ports for the same Sub SA ID.

It is important to note that IKE messages MUST NOT utilize these
ephemeral source ports. Instead, IKE traffic should be confined to
the source and destination ports to ensure proper protocol operation
and maintain compatibility with existing implementations.

When using ephemeral source ports, the receiver can only set the
source port upon arrival of an EESP packet with that Sub SA ID. If
the receiver is pre-populating a Sub SA, it may have to install it
with a source port set to zero and, upon arrival of a packet,
update the source port using a mapping change.

Additionally, when multiple Sub SAs exist, the receiver SHOULD
maintain a mapping table to track the source port associated with
each Sub SA independently. This ensures that traffic is correctly
routed and prevents ambiguity in handling packets associated with
different Sub SAs when a NAT is present.

** Key derivation for Sub SA

# [[RFC7296]] section 2.17 specifies Child SA key generation.

When the EESP SA is negotiated with a Sub SA Keys (SUB_SA_ID), each
Sub SA derives its own unique keys. This allows each Sub SA
its own independent Sequence Number space, and independent IV space.

The requirements:
- Independent keys for each Sub SA
- Ability to derive Sub SA keys on the fly with least amount of memory usage
- Minimal memory requirements
- Keyderviation support multiple SAs, such as EESP, AH
- Use the same Crypto primitive as used for encryption e.g. AES-*

*** Hierarchical key derivation
Hierarchical key derivation use Sub SA ID, which is carried in EESP
Seesion ID or in EESP Flow ID(TLV), as an input to the key dervivation.

Section 2.17 [[RFC7296]] specifies a KEYMAT derivation. The KEYMAT is split into

SK_ai, SK_ar, SK_ei, SK_er. Each of these keys MUST be used as master key to derive
further Sub SA specific key.

SK_S_xx = prf+(prf+(SK_xx,Sub SA ID))

for e.g. SK_S_ei = prf+(prf+(SK_ei, Sub SA ID))

The Sub SA keys can be derived in ESP sub system or in IKE sub system when pre installing
all SAs and keys.

One advantage of Hierarchical KDF is the Sub SA keys MAY BE
generated on the fly, for every packet, when available fast memory
is limited, for example [[PSP]]. This is usually the case when key
derivation is implemented in hardware. When implimenting in hardware
choose a hardware friendly prf+.

** Rekey Key Derivation.
During the EESP SA rekey, a new KEYMAT is derived using the new Ni
and Nr values. If a Key Exchange (KE) method was used in the rekying,
CREATE_CHILD_SA exchange, the new key MAY also include g^ir as part of
the derivation process.

Even though each Sub SA can be independently rekeyed, for
simplicity, all Sub SAs MUST be rekeyed together
when either a cryptographic limit or a time-based limit is
reached.

The time-based limit, also described in Section 2.8 of
[RFC7296], ensures periodic key replacement to minimize the risks
associated with long-term key exposure, even if the cryptographic
limit has not been reached.

When rekeying is triggered for any of the Sub SA by whichever
limit—cryptographic or time- based—is reached first, subseqenty all
Sub SAs must rekeyed.


** Multiple Sender Group SA Key Derivation

When using EESP with a group SA, as specified in
[[I-D.ietf-ipsecme-g-ikev2]], the Sender-ID MUST be used for
deriving a unique key for each sender. This ensures that each
sender maintains a distinct IV and/or sequence number space.
When using independent keys, the Implicit IV (IIV) transforms
may be used.

The Sender-ID is carried in each packet within the Session ID
field, allowing efficient and reliable key differentiation for
data security and integrity.

The maximum length of GWP_SENDER_ID_BITS in GCKS policy
is 16 bits when using the Session ID to carry the Sender-ID.

[Note: we could allow 32 bit or any lenght field for
GWP_SENDER_ID_BITS then it would have be carried in
a EESP Options TLV and not in Session ID]

* Session ID

The Session ID is a multi-purpose attribute with mutually
exclusive values. The initiator MUST propose a single value in the
Child SA proposal, Transform EESPSSID (Value). The responder MUST
either accept the proposed value or reject it with an
INVALID_SESSION_ID error message, indicating a supported value.

* UDP Encapsulation for EESP

UDP encapsulation for EESP is largely similar to the ESP UDP
encapsulation specified in [[RFC3948]], with the primary difference
being the UDP source port used by the EESP Sub SA may be different
from IKE_SA source port, as specified in [[RFC3947]], for more
flexible handling of EESP traffic, particularly ECMP support
along the path and in the NIC.

A receiver indenting to support both ESP and EESP encapsulated in UDP
must start ESP  SPI, most significant bit of the SPI, with zero.

* EESP Crypt Offset Option
This option is typically used for within one Datacenter use case
such as [[PSP]]. To negotiate, the initiator sends USE_CRYPTOFFSET
together with USE_TRANSPORT_MODE and the responder respond with the
same. USE_EESP_CRYPTOFFSET is not supported in Tunnel mode or BEET
mode.
# Note STK:  This needs discussion
#
~NOTE~ Add EESP draft UDP section reference.

* IANA Considerations

** Changes in the Existing IKEv2 Registries

*** IKEv2 Security Protocol Identifiers registry
This document defines new Protocol ID in the
"IKEv2 Security Protocol Identifiers" registry, [[IKEv2-SP]]:

| Protocol ID | Protocol | Reference       |
|-------------+----------+-----------------+
| [TBD1]      | EESPv0   | [this document] |

*** IKEv2 Notify Message Status Types registry.

| Value | Notify Message Status Type |  Reference      |
|-------+----------------------------+-----------------+
| TBD8  | USE_EESP_CRYPTOFFSET       | [this document] |

*** Extending ESP with EESP
Several tables in [[IKEv2-IANA]] that specify ESP as protocol
should be extended with EESP. Should we list each table one by one or
specify as replace ESP, with ESP, EESP.e.g in the Transform Type Values,
replace 'IKE and ESP' with 'IKE, ESP, and EESP'

Changes the "Used In" column for the existing allocations as follows;

*** Sequence Number

This document defines a new value in the IKEv2 "Transform Type 5 - Sequence
   Numbers Properties Transform IDs" registry:

| Value   | Name                          | Reference       |
|---------+-------------------------------+-----------------+
| [TBD9]  | 64-bit Sequential Numbers     | [this document] |
| [TBD10] | None                          | [this document] |


* Implementation Status

[Note to RFC Editor: Please remove this section and the reference to
[[RFC7942]] before publication.]

This section records the status of known implementations of the
protocol defined by this specification at the time of posting of this
Internet-Draft, and is based on a proposal described in [[RFC7942]].
The description of implementations in this section is intended to
assist the IETF in its decision processes in progressing drafts to
RFCs. Please note that the listing of any individual implementation
here does not imply endorsement by the IETF. Furthermore, no effort
has been spent to verify the information presented here that was
supplied by IETF contributors. This is not intended as, and must not
be construed to be, a catalog of available implementations or their
features. Readers are advised to note that other implementations may
exist.

According to [[RFC7942]], "this will allow reviewers and working
groups to assign due consideration to documents that have the benefit
of running code, which may serve as evidence of valuable
experimentation and feedback that have made the implemented protocols
more mature. It is up to the individual working groups to use this
information as they see fit".

Authors are requested to add a note to the RFC Editor at the top of
this section, advising the Editor to remove the entire section before
publication, as well as the reference to [[RFC7942]].


* Security Considerations

EESP option Crypt Offset [[I-D.klassert-ipsecme-eesp]] section [XXX]
allows exposing transport headers for telemetry.
It is indented use of within data center.

When an EESP receiver implementation uses Stateless Decryption, it
may not rely on single Security Policy Database (SPD) as specified in
the IPsec Architecture document [[RFC4301]], section 4.4.1. However,
the receiver MUST validate the negotiated Security Policy through
other means to ensure compliance with the intended security
requirements. For by adding Security Policy to the socket or route
entry. Also comply with ICMP  processing specified  in section 6 of
RFC4301.

Additional security relevant aspects of using the IPsec protocol are
discussed in the Security Architecture document [[RFC4301]]

* Acknowledgments

TBD

* Normative References

** RFC8174
** RFC5840
** RFC4303
** RFC7296
** RFC3948
** RFC4301
** RFC8126
** I-D.klassert-ipsecme-eesp
** I-D.ietf-ipsecme-ikev2-rename-esn


* Informative References

** RFC2119
** RFC9347
** RFC9611
** RFC3947
** RFC2992
** RFC7942
** RFC8750
** RFC4555
** RFC4106

** I-D.mrossberg-ipsecme-multiple-sequence-counters
** I-D.ponchon-ipsecme-anti-replay-subspaces
** I-D.ietf-ipsecme-g-ikev2

** PSP
:PROPERTIES:
:REF_TARGET: https://github.com/google/psp/blob/main/doc/PSP_Arch_Spec.pdf
:REF_TITLE: PSP Architecture Specification
:REF_ORG: Google
:END:

** IKEv2-IANA
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml
:REF_TITLE: IKEv2 Parameters
:REF_ORG: IANA
:END:

** IKEv2-Transforms
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-3
:REF_TITLE: IKEv2 Parameters: Transform Type Values
:REF_ORG: IANA
:END:

** IKEv2-SN
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-9
:REF_TITLE: IKEv2 Parameters: Encryption Algorithm Transform IDs
:REF_ORG: IANA
:END:

** IKEv2-Enc
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-5
:REF_TITLE: IKEv2 Parameters: Extended Sequence Numbers Transform IDs
:REF_ORG: IANA
:END:

** IKEv2-SP
:PROPERTIES:
:REF_TARGET: https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml#ikev2-parameters-18
:REF_TITLE: IKEv2 Parameters: Security Protocol Identifiers
:REF_ORG: IANA
:END:


* Additional Stuff

TBD
